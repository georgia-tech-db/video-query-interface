import {
  require_react
} from "./chunk-5J3VJD3X.js";
import {
  C,
  dn,
  fn,
  ln,
  sn
} from "./chunk-XUIKATUP.js";
import {
  nanoid
} from "./chunk-WEKECKQL.js";
import {
  __toESM
} from "./chunk-NKHIPFFU.js";

// ../../node_modules/@state-designer/react/dist/esm/index.js
var import_react = __toESM(require_react());

// ../../node_modules/@state-designer/core/dist/esm/index.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
function createDesign(design) {
  return __spreadProps(__spreadValues({}, design), {
    createEventHandlerDesign: (eventHandlerDesign) => eventHandlerDesign,
    createEventHandlerObjectDesign: (eventHandlerItemDesign) => eventHandlerItemDesign,
    createAsyncEventDesign: (asyncEventDesign) => asyncEventDesign,
    createRepeatEventDesign: (repeatEventDesign) => repeatEventDesign,
    createState: (stateDesign) => stateDesign,
    createActionDesign: (actionDesign) => actionDesign,
    createConditionDesign: (conditionDesign) => conditionDesign,
    createResultDesign: (resultDesign) => resultDesign,
    createTimeDesign: (timeDesign) => timeDesign,
    createValueDesign: (valueDesign) => valueDesign
  });
}
function testEventHandlerConditions(h, d, p, r) {
  try {
    if (h.if[0] && !h.if.every((c) => c(d, p, r)))
      return false;
    if (h.ifAny[0] && !h.ifAny.some((c) => c(d, p, r)))
      return false;
    if (h.unless[0] && !h.unless.every((c) => !c(d, p, r)))
      return false;
    if (h.unlessAny[0] && !h.unlessAny.some((c) => !c(d, p, r)))
      return false;
    return true;
  } catch (e) {
    throw Error(`Error while testing conditions! ` + e.message);
  }
}
function customError(message, error) {
  const err = new Error(message + " " + error.message);
  err.stack = error.stack;
  return err;
}
function createEventChain(options) {
  const { state, onDelayedOutcome, getFreshDataAfterWait } = options;
  const handlers = [...options.handler];
  const { payload } = options;
  let waiting = false;
  let core = {
    data: options.data,
    payload: options.payload,
    result: options.result
  };
  const finalOutcome = __spreadProps(__spreadValues({}, core), {
    shouldBreak: false,
    shouldNotify: false,
    pendingTransition: []
  });
  let draftCore = ln(core);
  let tResult = options.result;
  function complete(draft) {
    core = dn(draft);
    finalOutcome.result = core.result;
    finalOutcome.data = core.data;
  }
  function processHandlerObject(handler, draft) {
    if (handler.get.length > 0) {
      let fnName = "";
      try {
        for (const result of handler.get) {
          fnName = result.name;
          tResult = result(draft.data, payload, tResult);
        }
      } catch (e) {
        throw customError(`Error in result (${fnName})!`, e);
      }
      draft.result = tResult;
    }
    const passedConditions = testEventHandlerConditions(handler, draft.data, draft.payload, draft.result);
    if (passedConditions) {
      if (handler.do.length > 0) {
        finalOutcome.shouldNotify = true;
        let fnName = "";
        try {
          for (const action of handler.do) {
            fnName = action.name;
            const result = action(draft.data, draft.payload, draft.result);
            if (result) {
              Object.assign(draft.data, Object.freeze(result));
            }
          }
        } catch (e) {
          throw customError(`Error in action (${fnName})!`, e);
        }
      }
      if (handler.secretlyDo.length > 0) {
        let fnName = "";
        try {
          for (const action of handler.secretlyDo) {
            fnName = action.name;
            const result = action(draft.data, draft.payload, draft.result);
            if (result) {
              Object.assign(draft.data, Object.freeze(result));
            }
          }
        } catch (e) {
          throw customError(`Error in secret action (${fnName})!`, e);
        }
      }
      if (handler.to.length > 0) {
        let fnName = "";
        try {
          for (const fn2 of handler.to) {
            fnName = fn2.name;
            finalOutcome.pendingTransition.push(fn2(draft.data, draft.payload, draft.result));
          }
          finalOutcome.shouldBreak = true;
          finalOutcome.shouldNotify = true;
          return { shouldBreak: true };
        } catch (e) {
          throw customError(`Error computing transition (${fnName})!`, e);
        }
      }
      if (handler.secretlyTo.length > 0) {
        let fnName = "";
        try {
          for (const fn2 of handler.secretlyTo) {
            fnName = fn2.name;
            finalOutcome.pendingTransition.push(fn2(draft.data, draft.payload, draft.result));
          }
          finalOutcome.shouldBreak = true;
          return { shouldBreak: true };
        } catch (e) {
          throw customError(`Error computing secret transition (${fnName})!`, e);
        }
      }
      if (handler.then !== void 0) {
        processEventHandler([...handler.then], draft);
      }
      if (handler.break !== void 0) {
        try {
          if (handler.break(draft.data, draft.payload, draft.result)) {
            return { shouldBreak: true };
          }
        } catch (e) {
          throw customError(`Error computing break (${handler.break.name})!`, e);
        }
      }
    } else {
      if (handler.else !== void 0) {
        processEventHandler([...handler.else], draft);
      }
    }
    return { shouldBreak: false };
  }
  function processEventHandler(eventHandler, draft) {
    if (finalOutcome.shouldBreak) {
      return { shouldBreakDueToWait: false };
    }
    const nextHandlerObject = eventHandler.shift();
    if (nextHandlerObject === void 0) {
      return { shouldBreakDueToWait: false };
    } else if (nextHandlerObject.wait !== void 0) {
      const waitTime = nextHandlerObject.wait(draft.data, payload, draft.result) * 1e3;
      if (waiting && finalOutcome.shouldNotify) {
        complete(draftCore);
        onDelayedOutcome(finalOutcome);
      }
      waiting = true;
      state.times.timeouts[0] = setTimeout(() => {
        core.data = getFreshDataAfterWait();
        core.result = void 0;
        draftCore = ln(core);
        const { shouldBreak } = processHandlerObject(nextHandlerObject, draftCore);
        if (!shouldBreak) {
          const { shouldBreakDueToWait } = processEventHandler(handlers, draftCore);
          if (shouldBreakDueToWait) {
            return;
          }
        }
        complete(draftCore);
        onDelayedOutcome(finalOutcome);
      }, waitTime);
      return { shouldBreakDueToWait: true };
    } else {
      const { shouldBreak } = processHandlerObject(nextHandlerObject, draft);
      if (!shouldBreak) {
        return processEventHandler(eventHandler, draft);
      }
      return { shouldBreakDueToWait: false };
    }
  }
  processEventHandler(handlers, draftCore);
  complete(draftCore);
  return finalOutcome;
}
function last(array) {
  const length = array == null ? 0 : array.length;
  return array[length - 1];
}
function castArray(a) {
  return Array.isArray(a) ? a : [a];
}
function deactivateState(state) {
  state.active = false;
  for (const childState of Object.values(state.states)) {
    deactivateState(childState);
  }
}
function getActiveStates(state) {
  const acc = [];
  if (state.active) {
    acc.push(state);
    for (const childState of Object.values(state.states)) {
      acc.push(...getActiveStates(childState));
    }
  }
  return acc;
}
function activateState(state, path, before, prev, deep) {
  let isTarget = false;
  state.active = true;
  if (state.name === path[0]) {
    path.shift();
    if (path.length === 0) {
      isTarget = true;
    }
  }
  if (state.initial === void 0) {
    Object.values(state.states).forEach((c) => activateState(c, path, before, prev, deep));
  } else if (prev && path.length === 0) {
    const c = state.states[last(state.history) || state.initial];
    activateState(c, path, before, deep, deep);
  } else if (state.states[path[0]] !== void 0) {
    const c = state.states[path[0]];
    state.history.push(c.name);
    activateState(c, path, before, prev, deep);
  } else if (!isTarget && before.includes(state)) {
    const c = state.states[last(state.history) || state.initial];
    activateState(c, path, before, false, false);
  } else {
    const c = state.states[state.initial];
    state.history.push(c.name);
    activateState(c, path, before, false, false);
  }
}
function findTransitionTargets(state, path) {
  const acc = [];
  const safePath = path.startsWith(".") ? path : "." + path;
  if (state.path.endsWith(safePath)) {
    acc.push(state);
  }
  for (const childState of Object.values(state.states)) {
    acc.push(...findTransitionTargets(childState, path));
  }
  return acc;
}
function getInitialState(initial, payload, data) {
  if (initial.else !== void 0) {
    let result = void 0;
    for (const resu of initial.get) {
      result = resu(data, payload, result);
    }
    if (testEventHandlerConditions(initial, data, payload, result)) {
      if (initial.then !== void 0) {
        return getInitialState(initial.then, payload, data);
      } else {
        return initial.to(data, payload, result);
      }
    } else {
      return getInitialState(initial.else, payload, data);
    }
  } else {
    return initial.to(data, payload, void 0);
  }
}
function setIntitialStates(state, payload, data) {
  if (state.initialFn !== void 0) {
    state.initial = getInitialState(state.initialFn, payload, data);
  }
  if (state.states !== void 0) {
    for (const child of Object.values(state.states)) {
      setIntitialStates(child, payload, data);
    }
  }
}
function endStateIntervals(state) {
  const { cancelAsync, timeouts, interval, animationFrame } = state.times;
  if (cancelAsync !== void 0) {
    cancelAsync();
    state.times.cancelAsync = void 0;
  }
  for (const timeout of timeouts) {
    clearTimeout(timeout);
  }
  state.times.timeouts = [];
  if (interval !== void 0) {
    clearInterval(interval);
    state.times.interval = void 0;
  }
  if (animationFrame !== void 0) {
    cancelAnimationFrame(animationFrame);
    state.times.animationFrame = void 0;
  }
}
function recursivelyEndStateIntervals(state) {
  endStateIntervals(state);
  for (const child of Object.values(state.states)) {
    recursivelyEndStateIntervals(child);
  }
}
function getStateTreeFromDesign(config, id) {
  const times = Object.fromEntries(Object.entries(config.times || {}).map(([k, v]) => {
    return [k, castToFunction(v)];
  }));
  function getEventFn(item, collection, collectionName) {
    if (typeof item === "string") {
      if (!collection) {
        throw Error(`No ${collectionName} in config!`);
      } else {
        const itemFromCollection = collection[item];
        if (typeof itemFromCollection === "undefined") {
          throw Error(`No item in ${collectionName} named ${item}!`);
        }
        return itemFromCollection;
      }
    } else {
      return item;
    }
  }
  function castToNamedFunction(item) {
    const fn2 = () => item;
    Object.defineProperty(fn2, "name", { value: item, writable: false });
    return fn2;
  }
  function castToFunction(item) {
    if (typeof item === "undefined")
      return void 0;
    return typeof item === "function" ? item : castToNamedFunction(item);
  }
  function getTransitions(items) {
    if (typeof items === "undefined")
      return [];
    return castArray(items).map((item) => typeof item === "function" ? item : castToNamedFunction(item));
  }
  function getResults(items) {
    if (typeof items === "undefined")
      return [];
    return castArray(items).map((item) => getEventFn(item, config.results, "results"));
  }
  function getConditions(items) {
    if (typeof items === "undefined")
      return [];
    return castArray(items).map((item) => getEventFn(item, config.conditions, "conditions"));
  }
  function getActions(items) {
    if (typeof items === "undefined")
      return [];
    return castArray(items).map((item) => getEventFn(item, config.actions, "actions"));
  }
  function getAsync(item) {
    return getEventFn(item, config.asyncs, "asyncs");
  }
  function getTime(item) {
    if (typeof item === "undefined")
      return void 0;
    return typeof item === "number" ? castToNamedFunction(item) : getEventFn(item, times, "times");
  }
  function getEventHandlerObject(itemCfg) {
    return {
      get: getResults(itemCfg.get),
      if: getConditions(itemCfg.if),
      ifAny: getConditions(itemCfg.ifAny),
      unless: getConditions(itemCfg.unless),
      unlessAny: getConditions(itemCfg.unlessAny),
      do: getActions(itemCfg.do),
      secretlyDo: getActions(itemCfg.secretlyDo),
      to: getTransitions(itemCfg.to),
      secretlyTo: getTransitions(itemCfg.secretlyTo),
      wait: getTime(itemCfg.wait),
      break: castToFunction(itemCfg.break),
      then: itemCfg.then ? getEventHandler(itemCfg.then) : void 0,
      else: itemCfg.else ? getEventHandler(itemCfg.else) : void 0
    };
  }
  function getEventHandler(event) {
    return castArray(event).map((eventHandler) => {
      switch (typeof eventHandler) {
        case "string": {
          if (typeof config.actions === "undefined") {
            throw new Error("Actions is undefined!");
          } else {
            const eventFn = config.actions && config.actions[eventHandler];
            return getEventHandlerObject({ do: eventFn });
          }
        }
        case "function": {
          return getEventHandlerObject({ do: eventHandler });
        }
        default: {
          return getEventHandlerObject(eventHandler);
        }
      }
    });
  }
  function getInitialState2(initial) {
    if (typeof initial === "undefined") {
      return;
    }
    if (typeof initial === "string" || !("else" in initial)) {
      const target = typeof initial === "string" ? initial : initial.to;
      return {
        get: [],
        if: [],
        unless: [],
        ifAny: [],
        unlessAny: [],
        to: typeof target === "function" ? target : castToNamedFunction(target)
      };
    } else {
      return {
        get: getResults(initial.get),
        if: getConditions(initial.if),
        unless: getConditions(initial.unless),
        ifAny: getConditions(initial.ifAny),
        unlessAny: getConditions(initial.unlessAny),
        to: typeof initial.to === "function" ? initial.to : castToNamedFunction(initial.to),
        then: getInitialState2(initial.then),
        else: getInitialState2(initial.else)
      };
    }
  }
  function createState2(state, name, path, active, depth, isInitial, parentType) {
    if (state.initial !== void 0 && state.states === void 0) {
      throw Error(`In ${path + name}, you've provided an initial state but no states!`);
    }
    const type = state.states ? state.initial ? "branch" : "parallel" : "leaf";
    return {
      name,
      type,
      isInitial,
      parentType,
      depth,
      path: path + name,
      active,
      activeId: 0,
      history: [],
      times: {
        timeouts: [],
        interval: void 0,
        animationFrame: void 0
      },
      initialFn: getInitialState2(state.initial),
      initial: void 0,
      onEnter: state.onEnter ? getEventHandler(state.onEnter) : void 0,
      onExit: state.onExit ? getEventHandler(state.onExit) : void 0,
      onEvent: state.onEvent ? getEventHandler(state.onEvent) : void 0,
      async: state.async ? {
        await: getAsync(state.async.await),
        onResolve: getEventHandler(state.async.onResolve),
        onReject: state.async.onReject ? getEventHandler(state.async.onReject) : void 0
      } : void 0,
      repeat: state.repeat ? {
        onRepeat: getEventHandler(state.repeat.onRepeat),
        delay: state.repeat.delay ? getTime(state.repeat.delay) : void 0
      } : void 0,
      on: Object.fromEntries(state.on ? Object.entries(state.on).map(([name2, event]) => [name2, getEventHandler(event)]) : []),
      states: Object.fromEntries(state.states ? Object.entries(state.states).map(([childName, childState]) => {
        return [
          childName,
          createState2(childState, childName, path + name + ".", false, depth + 1, state.initial === childName, type)
        ];
      }) : [])
    };
  }
  return createState2(config, "root", id + ".", true, 0, true, null);
}
C();
sn(false);
function createState(design) {
  var _a;
  const { options = {} } = design;
  const { suppressErrors = false, onSend } = options;
  let logEnabled = (_a = design.options) == null ? void 0 : _a.enableLog;
  function handleError(err, prefix) {
    var _a2;
    if (prefix) {
      err.message = prefix + ": " + err.message;
    }
    if ((_a2 = design.options) == null ? void 0 : _a2.onError) {
      design.options.onError(err);
    }
    if (suppressErrors) {
      throw err;
    } else {
      throw err;
    }
  }
  const subscribers = /* @__PURE__ */ new Set([]);
  function subscribe(callbackFn) {
    subscribers.add(callbackFn);
  }
  function unsubscribe(callbackFn) {
    if (subscribers.has(callbackFn)) {
      subscribers.delete(callbackFn);
    }
    if (subscribers.size === 0) {
      stopLoop();
      recursivelyEndStateIntervals(snapshot.stateTree);
    }
  }
  function notifySubscribers() {
    setValues();
    setLog();
    setActiveStates();
    subscribers.forEach((subscriber) => subscriber(snapshot));
  }
  function handleEventHandlerChainOutcome(outcome, payload) {
    snapshot.data = outcome.data;
    for (const transition of outcome.pendingTransition) {
      runTransition(transition, payload, outcome.result);
    }
  }
  function runEventHandlerChain(state, eventHandler, payload, result) {
    const outcome = createEventChain({
      state,
      data: snapshot.data,
      result,
      payload,
      handler: eventHandler,
      onDelayedOutcome: (outcome2) => {
        handleEventHandlerChainOutcome(outcome2, payload);
        if (outcome2.shouldNotify) {
          notifySubscribers();
        }
      },
      getFreshDataAfterWait: () => snapshot.data
    });
    handleEventHandlerChainOutcome(outcome, payload);
    return outcome;
  }
  function handleEventOnState(state, sent) {
    const record = { shouldHalt: false, shouldNotify: false };
    if (!state.active)
      return record;
    const activeChildren = Object.values(state.states).filter((state2) => state2.active);
    const eventHandler = state.on[sent.event];
    let outcome = void 0;
    if (typeof eventHandler !== "undefined") {
      outcome = runEventHandlerChain(state, eventHandler, sent.payload, void 0);
      if (outcome.shouldNotify) {
        record.shouldNotify = true;
      }
      if (outcome.shouldBreak) {
        record.shouldNotify = true;
        record.shouldHalt = true;
        return record;
      }
    }
    if (typeof state.onEvent !== "undefined") {
      outcome = runEventHandlerChain(state, state.onEvent, sent.payload, outcome == null ? void 0 : outcome.result);
      if (outcome.shouldNotify) {
        record.shouldNotify = true;
      }
      if (outcome.shouldBreak) {
        record.shouldNotify = true;
        record.shouldHalt = true;
        return record;
      }
    }
    for (const childState of activeChildren) {
      const childRecord = handleEventOnState(childState, sent);
      if (childRecord.shouldNotify) {
        record.shouldNotify = true;
      }
      if (childRecord.shouldHalt) {
        record.shouldNotify = true;
        record.shouldHalt = true;
        return record;
      }
    }
    return record;
  }
  function runTransition(path, payload, result) {
    const isPreviousTransition = path.endsWith(".previous");
    const isRestoreTransition = path.endsWith(".restore");
    if (isPreviousTransition) {
      path = path.slice(0, path.length - 9);
    } else if (isRestoreTransition) {
      path = path.slice(0, path.length - 8);
    }
    const targets = findTransitionTargets(snapshot.stateTree, path);
    const target = last(targets);
    if (typeof target === "undefined") {
      throw Error(`Error in transition (${path})! Could not find that state.`);
    }
    const pathDown = target.path.split(".").slice(1);
    const beforeActive = getActiveStates(snapshot.stateTree);
    deactivateState(snapshot.stateTree);
    setIntitialStates(snapshot.stateTree, payload, snapshot.data);
    activateState(snapshot.stateTree, pathDown, beforeActive, isPreviousTransition || isRestoreTransition, isRestoreTransition);
    const afterActive = getActiveStates(snapshot.stateTree);
    const deactivatedStates = beforeActive.filter((state) => !afterActive.includes(state));
    const newlyActivatedStates = afterActive.filter((state) => !beforeActive.includes(state));
    deactivatedStates.forEach((state) => {
      endStateIntervals(state);
      removeOnFrameEventHandler(state);
    });
    for (const state of deactivatedStates) {
      const { onExit } = state;
      state.activeId++;
      if (typeof onExit !== "undefined") {
        const onExitOutcome = runEventHandlerChain(state, onExit, payload, result);
        if (onExitOutcome.shouldBreak)
          return;
      }
    }
    for (const state of newlyActivatedStates) {
      const { async, repeat, onEnter } = state;
      if (typeof repeat !== "undefined") {
        const { onRepeat, delay } = repeat;
        let now = performance.now();
        let elapsed = 0;
        let realInterval = 0;
        if (delay === void 0) {
          addOnFrameState(state, { payload, start: now });
        } else {
          let lastTime2 = performance.now();
          const s = delay(snapshot.data, payload, result);
          state.times.interval = setInterval(() => {
            now = performance.now();
            realInterval = now - lastTime2;
            elapsed += realInterval;
            lastTime2 = now;
            const outcome = runEventHandlerChain(state, onRepeat, payload, {
              interval: realInterval,
              elapsed
            });
            if (outcome.shouldNotify)
              notifySubscribers();
          }, Math.max(1 / 60, s * 1e3));
        }
      }
      if (typeof onEnter !== "undefined") {
        const onEnterOutcome = runEventHandlerChain(state, onEnter, payload, result);
        if (onEnterOutcome.shouldBreak)
          return;
      }
      if (typeof async !== "undefined") {
        let finished = false;
        state.times.cancelAsync = () => finished = true;
        async.await(snapshot.data, payload, result).then((resolved) => {
          if (finished)
            return;
          const localUpdate = runEventHandlerChain(state, async.onResolve, payload, resolved);
          if (localUpdate.shouldNotify)
            notifySubscribers();
        }, (rejected) => {
          if (typeof async.onReject !== "undefined") {
            if (finished)
              return;
            const localUpdate = runEventHandlerChain(state, async.onReject, payload, rejected);
            if (localUpdate.shouldNotify)
              notifySubscribers();
          }
        });
      }
    }
  }
  function enableLog(enabled) {
    logEnabled = enabled;
  }
  function logEvent(event) {
    if (logEnabled) {
      _log.unshift(event);
    } else {
      _log = [event];
    }
  }
  function setLog() {
    snapshot.index++;
    snapshot.log = [..._log];
  }
  function setValues() {
    snapshot.values = getValues(snapshot.data, design.values);
  }
  function setActiveStates() {
    _activeStates = getActiveStates(snapshot.stateTree);
    snapshot.active = getPaths(_activeStates);
  }
  let lastTime = -1;
  let interval = -1;
  let frameInterval = void 0;
  const onFrameStates = /* @__PURE__ */ new Map([]);
  function loop(ms) {
    var _a2;
    let shouldNotify = false;
    if (lastTime < 0)
      lastTime = ms;
    interval = ms - lastTime;
    lastTime = ms;
    const states = Array.from(onFrameStates.entries());
    for (const [state, info] of states) {
      if (((_a2 = state.repeat) == null ? void 0 : _a2.onRepeat) !== void 0) {
        const outcome = runEventHandlerChain(state, state.repeat.onRepeat, info.payload, {
          interval,
          elapsed: ms - info.start
        });
        if (outcome.shouldNotify) {
          shouldNotify = true;
        }
        if (outcome.shouldBreak) {
          break;
        }
      }
    }
    if (shouldNotify)
      notifySubscribers();
    if (frameInterval === void 0)
      return;
    frameInterval = requestAnimationFrame(loop);
  }
  function stopLoop() {
    if (frameInterval !== void 0) {
      cancelAnimationFrame(frameInterval);
      frameInterval = void 0;
      lastTime = -1;
      interval = -1;
    }
  }
  function startLoop() {
    frameInterval = requestAnimationFrame(loop);
  }
  function addOnFrameState(state, info) {
    onFrameStates.set(state, info);
    if (frameInterval === void 0) {
      startLoop();
    }
  }
  function removeOnFrameEventHandler(state) {
    if (onFrameStates.has(state)) {
      onFrameStates.delete(state);
      if (onFrameStates.size === 0) {
        stopLoop();
      }
    }
  }
  function onUpdate(callbackFn) {
    subscribe(callbackFn);
    return () => unsubscribe(callbackFn);
  }
  function getUpdate(callbackFn) {
    setValues();
    setActiveStates();
    setLog();
    callbackFn(snapshot);
  }
  function send(eventName, payload, onSettle) {
    try {
      const { shouldNotify } = handleEventOnState(snapshot.stateTree, {
        event: eventName,
        payload
      });
      logEvent(eventName);
      if (shouldNotify)
        notifySubscribers();
      onSettle == null ? void 0 : onSettle(snapshot);
      onSend == null ? void 0 : onSend(eventName, payload, shouldNotify);
    } catch (e) {
      handleError(e, eventName);
    }
    return snapshot;
  }
  const sendCache = /* @__PURE__ */ new Map([]);
  function thenSend(eventName) {
    let cached = sendCache.get(eventName);
    if (!cached) {
      cached = () => send(eventName);
      sendCache.set(eventName, cached);
    }
    return cached;
  }
  function isIn(...paths) {
    try {
      return castArray(paths).map((path) => path.startsWith(".") ? path : "." + path).every((path) => _activeStates.find((state) => state.path.endsWith(path)) !== void 0);
    } catch (e) {
      handleError(customError(`Error testing isIn(${paths.join()})!`, e));
      return false;
    }
  }
  function isInAny(...paths) {
    try {
      return castArray(paths).map((path) => path.startsWith(".") ? path : "." + path).some((path) => _activeStates.find((state) => state.path.endsWith(path)) !== void 0);
    } catch (e) {
      handleError(customError(`Error testing isInAny(${paths.join()})!`, e));
      return false;
    }
  }
  function can(eventName, payload, result) {
    return typeof _activeStates.find((state) => {
      const eventHandler = state.on[eventName];
      if (typeof eventHandler === "undefined")
        return;
      try {
        return eventHandler.some((handler) => {
          result = void 0;
          for (const resu of handler.get) {
            result = resu(snapshot.data, payload, result);
          }
          return testEventHandlerConditions(handler, snapshot.data, payload, result);
        });
      } catch (e) {
        handleError(customError(`Error testing can(${eventName})!`, e));
        return false;
      }
    }) !== "undefined";
  }
  function whenIn(paths, reducer = "value", initialValue) {
    const entries = [];
    Object.entries(paths).forEach(([key, value]) => {
      const v = typeof value === "function" ? value() : value;
      if (key === "root") {
        entries.push([key, v]);
      } else {
        if (_activeStates.find((v2) => {
          const safeKey = key.startsWith(".") ? key : "." + key;
          return v2.path.endsWith(safeKey);
        })) {
          entries.push([key, v]);
        }
      }
    });
    if (entries.length === 0) {
      if (typeof paths.default !== "undefined") {
        entries.push(["default", paths.default]);
      }
    }
    let returnValue;
    let rdcr;
    if (reducer === "array") {
      returnValue = [];
      rdcr = (a, [_, v]) => [...a, v];
    } else if (reducer === "value") {
      returnValue = void 0;
      rdcr = (_, [__, v]) => v;
    } else {
      returnValue = initialValue;
      rdcr = reducer;
    }
    entries.forEach((entry, i) => returnValue = rdcr(returnValue, entry, i, entries));
    return returnValue;
  }
  function getDesign() {
    return design;
  }
  function clone() {
    return createState(design);
  }
  function forceTransition(target, payload) {
    logEvent(`Forced transition to: ${target}`);
    runTransition(target, payload, void 0);
    notifySubscribers();
    return snapshot;
  }
  function forceData(data) {
    snapshot.data = data;
    logEvent("Forced data.");
    notifySubscribers();
    return snapshot;
  }
  function reset() {
    stopLoop();
    recursivelyEndStateIntervals(snapshot.stateTree);
    _log = [];
    Object.assign(snapshot, {
      data: fn(design.data, (d) => d),
      stateTree: getStateTreeFromDesign(design, id),
      log: []
    });
    deactivateState(snapshot.stateTree);
    runTransition("root", void 0, void 0);
    notifySubscribers();
    return snapshot;
  }
  const id = "#" + (typeof design.id !== "undefined" ? `state_${nanoid()}` : design.id);
  const initialStateTree = getStateTreeFromDesign(design, id);
  let _log = [];
  let _activeStates = getActiveStates(initialStateTree);
  const snapshot = {
    id,
    data: fn(design.data, (d) => d),
    active: getPaths(_activeStates),
    values: getValues(design.data, design.values),
    stateTree: initialStateTree,
    log: _log,
    index: 0,
    send,
    thenSend,
    isIn,
    isInAny,
    can,
    whenIn,
    getDesign,
    onUpdate,
    getUpdate,
    enableLog,
    forceData,
    forceTransition,
    clone,
    reset
  };
  deactivateState(snapshot.stateTree);
  runTransition("root", void 0, void 0);
  setValues();
  setActiveStates();
  setLog();
  return snapshot;
}
function getPaths(states) {
  return states.map((state) => state.path);
}
function getValues(data, values) {
  return Object.entries(values || {}).reduce((acc, [key, fn2]) => {
    acc[key] = fn2(data);
    return acc;
  }, {});
}
var types_exports = {};
__export(types_exports, {
  VerboseType: () => VerboseType
});
var VerboseType;
(function(VerboseType2) {
  VerboseType2["Condition"] = "condition";
  VerboseType2["Action"] = "action";
  VerboseType2["SecretAction"] = "secretAction";
  VerboseType2["Event"] = "event";
  VerboseType2["State"] = "state";
  VerboseType2["AsyncEvent"] = "asyncEvent";
  VerboseType2["TransitionEvent"] = "transitionEvent";
  VerboseType2["RepeatEvent"] = "repeatEvent";
  VerboseType2["Transition"] = "transition";
  VerboseType2["Notification"] = "notification";
  VerboseType2["EventHandler"] = "eventHandler";
  VerboseType2["Queue"] = "queue";
})(VerboseType || (VerboseType = {}));

// ../../node_modules/@state-designer/react/dist/esm/index.js
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useLocalState(design, dependencies = []) {
  const rFirstMount = (0, import_react.useRef)(true);
  const [current, setCurrent] = (0, import_react.useState)(() => createState(design));
  (0, import_react.useEffect)(() => {
    function handleUpdate(update) {
      setCurrent((current2) => __spreadProps2(__spreadValues2({}, current2), {
        index: update.index,
        data: update.data,
        active: update.active,
        stateTree: update.stateTree,
        values: update.values,
        log: update.log
      }));
    }
    if (!rFirstMount.current) {
      const next = createState(design);
      setCurrent(next);
      return next.onUpdate(handleUpdate);
    }
    rFirstMount.current = false;
    return current.onUpdate(handleUpdate);
  }, [...dependencies]);
  return current;
}
function useGlobalState(design) {
  const [current, setCurrent] = (0, import_react2.useState)(() => design);
  (0, import_react2.useEffect)(() => {
    setCurrent(design);
    return design.onUpdate((update) => setCurrent((current2) => __spreadProps2(__spreadValues2({}, current2), {
      index: update.index,
      data: update.data,
      active: update.active,
      stateTree: update.stateTree,
      values: update.values,
      log: update.log
    })));
  }, [design]);
  return current;
}
var emptyArray = [];
function useStateDesigner(design, dependencies = emptyArray) {
  const rFirstMount = (0, import_react3.useRef)(true);
  const [current, setCurrent] = (0, import_react3.useState)(() => "active" in design ? design : createState(design));
  (0, import_react3.useEffect)(() => {
    if (!("active" in design))
      return;
    setCurrent(design);
    return design.onUpdate((update) => setCurrent((current2) => __spreadProps2(__spreadValues2({}, current2), {
      index: update.index,
      data: update.data,
      active: update.active,
      stateTree: update.stateTree,
      values: update.values,
      log: update.log
    })));
  }, [design]);
  (0, import_react3.useEffect)(() => {
    if ("active" in design)
      return;
    function handleUpdate(update) {
      setCurrent((current2) => __spreadProps2(__spreadValues2({}, current2), {
        index: update.index,
        data: update.data,
        active: update.active,
        stateTree: update.stateTree,
        values: update.values,
        log: update.log
      }));
    }
    if (!rFirstMount.current) {
      const next = createState(design);
      setCurrent(next);
      return next.onUpdate(handleUpdate);
    }
    rFirstMount.current = false;
    return current.onUpdate(handleUpdate);
  }, [...dependencies]);
  return current;
}
function useSelector(state, selectFn, compareFn = (prev, next) => prev === next) {
  const [inner, dispatch] = (0, import_react4.useReducer)((state2, update) => {
    const next = selectFn(update);
    return compareFn(state2.current, next) ? state2 : {
      count: state2.count + 1,
      current: next
    };
  }, state, (state2) => ({
    count: 0,
    current: selectFn(state2)
  }));
  (0, import_react4.useEffect)(() => state.onUpdate((update) => dispatch(update)), [state, dispatch]);
  return inner.current;
}
function createSelectorHook(state) {
  return function useSelector2(selectFn, compareFn = (prev, next) => prev === next) {
    const [inner, dispatch] = (0, import_react5.useReducer)((state2, update) => {
      const next = selectFn(update);
      return compareFn(state2.current, next) ? state2 : {
        count: state2.count + 1,
        current: next
      };
    }, state, (state2) => ({
      count: 0,
      current: selectFn(state2)
    }));
    (0, import_react5.useEffect)(() => state.onUpdate((update) => dispatch(update)), [dispatch]);
    return inner.current;
  };
}
var EventList = ({ state }) => {
  function getEvents(state2) {
    const localEvents = [];
    if (state2.active) {
      localEvents.push(...Object.keys(state2.on));
    }
    for (const child of Object.values(state2.states)) {
      localEvents.push(...getEvents(child));
    }
    return localEvents;
  }
  const eventMap = /* @__PURE__ */ new Map([]);
  for (const event of getEvents(state)) {
    const prior = eventMap.get(event);
    if (prior === void 0) {
      eventMap.set(event, 1);
    } else {
      eventMap.set(event, prior + 1);
    }
  }
  return (0, import_react6.createElement)("ul", {
    className: "list event"
  }, Array.from(eventMap.entries()).map(([eventName, count], i) => (0, import_react6.createElement)("li", {
    key: i,
    className: "item event"
  }, eventName, count > 1 && ` x${count}`)));
};
var StateNode = ({ state }) => {
  const { active } = state;
  const states = Object.values(state.states);
  return (0, import_react6.createElement)("li", {
    "data-active": active,
    className: "item state"
  }, active ? (0, import_react6.createElement)("b", null, state.name) : state.name, states.length > 0 && (0, import_react6.createElement)("ul", {
    className: "list state"
  }, states.map((child, i) => (0, import_react6.createElement)(StateNode, {
    key: i,
    state: child
  }))));
};
var StateGraph = (_a) => {
  var _b = _a, { state } = _b, rest = __objRest(_b, ["state"]);
  const { stateTree } = useStateDesigner(state, [state]);
  return (0, import_react6.createElement)("div", __spreadValues2({}, rest), (0, import_react6.createElement)("span", {
    className: "title states"
  }, "States:"), (0, import_react6.createElement)("ul", null, (0, import_react6.createElement)(StateNode, {
    state: stateTree
  })), (0, import_react6.createElement)("span", {
    className: "title events"
  }, "Events:"), (0, import_react6.createElement)(EventList, {
    state: stateTree
  }));
};
export {
  types_exports as S,
  StateGraph,
  createDesign,
  createSelectorHook,
  createState,
  useGlobalState,
  useLocalState,
  useSelector,
  useStateDesigner
};
//# sourceMappingURL=@state-designer_react.js.map
